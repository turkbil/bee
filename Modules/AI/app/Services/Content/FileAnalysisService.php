<?php

declare(strict_types=1);

namespace Modules\AI\app\Services\Content;

use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Modules\AI\App\Services\AIService;
use Modules\AI\App\Services\Template\TemplateEngine;

/**
 * File Analysis Service - PDF/Image ‚Üí Web Format Converter
 *
 * PDF'leri ve g√∂rselleri analiz ederek web formatƒ±na d√∂n√º≈üt√ºr√ºr
 * Ge√ßici dosyalar otomatik olarak silinir
 */
class FileAnalysisService
{
    private AIService $aiService;
    private TemplateEngine $templateEngine;

    public function __construct()
    {
        $this->aiService = app(\Modules\AI\App\Services\AIService::class);
        $this->templateEngine = app(TemplateEngine::class);
    }

    /**
     * Multiple files analiz et
     */
    public function analyzeFiles(array $files, string $analysisType = 'layout_preserve'): array
    {
        try {
            Log::info('üîç File analysis ba≈üladƒ±', [
                'file_count' => count($files),
                'analysis_type' => $analysisType
            ]);

            $results = [];
            $combinedContent = '';
            $tempPaths = []; // Cleanup i√ßin temp path'leri track et

            foreach ($files as $file) {
                $result = $this->analyzeSingleFile($file, $analysisType);
                $results[] = $result;

                if ($result['success']) {
                    $combinedContent .= "\n\n" . $result['extracted_content'];

                    // Temp path'i track et (cleanup i√ßin)
                    if (isset($result['temp_path'])) {
                        $tempPaths[] = $result['temp_path'];
                    }
                }
            }

            // Combined analysis for multiple files
            if (count($files) > 1) {
                $combinedContent = $this->combineMultipleFileContents($results, $analysisType);
            }

            $finalResult = [
                'success' => true,
                'file_type' => count($files) > 1 ? 'multiple' : ($results[0]['file_type'] ?? 'unknown'),
                'analysis_type' => $analysisType,
                'extracted_content' => trim($combinedContent),
                'individual_results' => $results,
                'analysis_summary' => $this->generateAnalysisSummary($results),
                'temp_paths' => $tempPaths
            ];

            // üóëÔ∏è INSTANT CLEANUP - Analiz sonrasƒ± hemen temizle
            $this->cleanupTempFiles($tempPaths);

            // ü§ñ AUTOMATIC CLEANUP SYSTEM - T√ºm temp dosyalarƒ± otomatik temizlenecek
            \Modules\AI\app\Services\Content\AutoCleanupService::scheduleAutomaticCleanup();

            return $finalResult;

        } catch (\Exception $e) {
            Log::error('‚ùå File analysis error: ' . $e->getMessage());

            return [
                'success' => false,
                'error' => 'Dosya analizi ba≈üarƒ±sƒ±z: ' . $e->getMessage()
            ];
        }
    }

    /**
     * Single file analiz et
     */
    private function analyzeSingleFile(UploadedFile $file, string $analysisType): array
    {
        $fileType = $this->detectFileType($file);

        switch ($fileType) {
            case 'pdf':
                return $this->analyzePDF($file, $analysisType);
            case 'image':
                return $this->analyzeImage($file, $analysisType);
            default:
                throw new \Exception('Desteklenmeyen dosya tipi: ' . $fileType);
        }
    }

    /**
     * PDF analiz et
     */
    private function analyzePDF(UploadedFile $file, string $analysisType): array
    {
        $tempPath = null;

        try {
            // üî• PDF HASH CACHE Sƒ∞STEMƒ∞ - Aynƒ± dosya tekrar i≈ülenmesin!
            $fileContent = $file->get();
            $pdfHash = hash('sha256', $fileContent);
            $cacheKey = "pdf_analysis:{$pdfHash}:{$analysisType}";

            // Cache'den kontrol et (7 g√ºn cache)
            if (\Cache::has($cacheKey)) {
                Log::info('‚ö° PDF cache hit - kredi harcanmadƒ±!', [
                    'file_name' => $file->getClientOriginalName(),
                    'pdf_hash' => substr($pdfHash, 0, 12),
                    'cache_key' => $cacheKey
                ]);

                $cachedResult = \Cache::get($cacheKey);
                $cachedResult['file_name'] = $file->getClientOriginalName(); // Dosya adƒ±nƒ± g√ºncelle
                $cachedResult['from_cache'] = true;
                return $cachedResult;
            }

            // PDF'i ge√ßici olarak kaydet
            $tempPath = $file->store('temp/pdf-analysis', 'local');
            $fullPath = Storage::disk('local')->path($tempPath);

            Log::info('üìÑ PDF analysis ba≈üladƒ±', [
                'file_name' => $file->getClientOriginalName(),
                'temp_path' => $tempPath,
                'analysis_type' => $analysisType,
                'pdf_hash' => substr($pdfHash, 0, 12)
            ]);

            // PDF text extraction
            $textContent = $this->extractPDFText($fullPath);

            // Eƒüer text extraction ba≈üarƒ±sƒ±z olduysa, fallback content
            if (empty(trim($textContent)) || str_contains($textContent, 'PDF text extraction failed')) {
                Log::warning('‚ö†Ô∏è PDF text extraction failed, using fallback content');
                $textContent = 'PDF content could not be extracted. Please provide manual description or use a different PDF.';
            }

            // PDF layout analysis (eƒüer layout_preserve ise)
            $layoutInfo = [];
            if ($analysisType === 'layout_preserve') {
                $layoutInfo = $this->analyzePDFLayout($fullPath);
            }

            // üñºÔ∏è PDF ƒ∞√áƒ∞NDEKƒ∞ G√ñRSELLER - G√∂rselleri √ßƒ±kar ve listele
            $extractedImages = $this->extractPDFImages($fullPath);
            Log::info('üñºÔ∏è PDF g√∂rsel extraction', [
                'image_count' => count($extractedImages),
                'images_found' => !empty($extractedImages)
            ]);

            // üö´ AI ENHANCEMENT YOK - Direkt raw text kullan
            $enhancedContent = $textContent;

            $result = [
                'success' => true,
                'file_type' => 'pdf',
                'file_name' => $file->getClientOriginalName(),
                'raw_text' => $textContent,
                'layout_info' => $layoutInfo,
                'extracted_content' => $enhancedContent,
                'extracted_images' => $extractedImages, // üñºÔ∏è YENƒ∞: PDF'deki g√∂rseller
                'image_count' => count($extractedImages),
                'analysis_type' => $analysisType,
                'temp_path' => $tempPath,
                'pdf_hash' => $pdfHash,
                'from_cache' => false
            ];

            // üî• CACHE'E KAYDET (7 g√ºn) - Dosya adƒ±nƒ± cache'leme, sadece i√ßeriƒüi
            $cacheableResult = $result;
            unset($cacheableResult['file_name']); // Dosya adƒ± deƒüi≈üebilir
            unset($cacheableResult['temp_path']); // Temp path'i cache'leme
            \Cache::put($cacheKey, $cacheableResult, now()->addDays(7));

            Log::info('üíæ PDF analysis cached', [
                'cache_key' => $cacheKey,
                'content_length' => strlen($enhancedContent),
                'cache_duration' => '7 days'
            ]);

            return $result;

        } catch (\Exception $e) {
            // Hata durumunda da instant cleanup yap
            if ($tempPath) {
                $this->cleanupTempFiles([$tempPath]);
            }

            Log::error('‚ùå PDF analysis error: ' . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Image analiz et
     */
    private function analyzeImage(UploadedFile $file, string $analysisType): array
    {
        $tempPath = null;

        try {
            // Image'ƒ± ge√ßici olarak kaydet
            $tempPath = $file->store('temp/image-analysis', 'local');
            $fullPath = Storage::disk('local')->path($tempPath);

            Log::info('üñºÔ∏è Image analysis ba≈üladƒ±', [
                'file_name' => $file->getClientOriginalName(),
                'temp_path' => $tempPath,
                'analysis_type' => $analysisType
            ]);

            // Image'ƒ± base64'e √ßevir (Claude Vision i√ßin)
            $imageData = base64_encode(file_get_contents($fullPath));
            $mimeType = $file->getMimeType();

            // Claude Vision ile image analysis
            $analysisResult = $this->analyzeImageWithAI($imageData, $mimeType, $analysisType);

            return [
                'success' => true,
                'file_type' => 'image',
                'file_name' => $file->getClientOriginalName(),
                'mime_type' => $mimeType,
                'extracted_content' => $analysisResult['content'],
                'layout_analysis' => $analysisResult['layout'] ?? [],
                'analysis_type' => $analysisType,
                'temp_path' => $tempPath
            ];

        } catch (\Exception $e) {
            // Hata durumunda da instant cleanup yap
            if ($tempPath) {
                $this->cleanupTempFiles([$tempPath]);
            }

            Log::error('‚ùå Image analysis error: ' . $e->getMessage());
            throw $e;
        }
    }

    /**
     * PDF text extraction (using smalot/pdfparser)
     */
    private function extractPDFText(string $pdfPath): string
    {
        try {
            // PDF Parser kullan - eƒüer kurulu deƒüilse basic fallback
            if (class_exists('\\Smalot\\PdfParser\\Parser')) {
                $parser = new \Smalot\PdfParser\Parser();
                $pdf = $parser->parseFile($pdfPath);
                $text = $pdf->getText();
            } else {
                // Fallback: Basic file content
                Log::warning('‚ö†Ô∏è smalot/pdfparser not installed, using basic text extraction');
                $text = 'PDF text extraction requires smalot/pdfparser package. Please install: composer require smalot/pdfparser';
            }

            // Text temizleme
            $text = preg_replace('/\s+/', ' ', $text); // Multiple spaces
            $text = preg_replace('/\n+/', "\n", $text); // Multiple newlines

            return trim($text);

        } catch (\Exception $e) {
            Log::error('‚ùå PDF text extraction error: ' . $e->getMessage());
            return 'PDF text extraction failed: ' . $e->getMessage();
        }
    }

    /**
     * PDF layout analysis (using advanced techniques)
     */
    private function analyzePDFLayout(string $pdfPath): array
    {
        try {
            // Basic layout detection
            if (!class_exists('\\Smalot\\PdfParser\\Parser')) {
                return ['error' => 'smalot/pdfparser required for layout analysis'];
            }

            $parser = new \Smalot\PdfParser\Parser();
            $pdf = $parser->parseFile($pdfPath);

            $pages = $pdf->getPages();
            $layoutInfo = [
                'page_count' => count($pages),
                'structure' => [],
                'fonts' => [],
                'colors' => []
            ];

            foreach ($pages as $pageIndex => $page) {
                $pageLayout = [
                    'page' => $pageIndex + 1,
                    'text_blocks' => $this->detectTextBlocks($page),
                    'headings' => $this->detectHeadings($page),
                    'lists' => $this->detectLists($page)
                ];

                $layoutInfo['structure'][] = $pageLayout;
            }

            return $layoutInfo;

        } catch (\Exception $e) {
            Log::error('‚ùå PDF layout analysis error: ' . $e->getMessage());
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Image analysis with Claude Vision
     */
    private function analyzeImageWithAI(string $imageData, string $mimeType, string $analysisType): array
    {
        try {
            $analysisPrompt = $this->buildImageAnalysisPrompt($analysisType);

            // Claude Vision API call - API key'i set et
            $anthropicService = app(\Modules\AI\App\Services\AnthropicService::class);

            // Config'den API key al
            $apiKey = config('ai.providers.anthropic.api_key');
            if (empty($apiKey)) {
                throw new \Exception('Anthropic API key not configured. Please set ANTHROPIC_API_KEY in .env file');
            }

            // API key ve model ayarlarƒ±nƒ± set et
            $anthropicService->setApiKey($apiKey);
            $anthropicService->setModel(config('ai.providers.anthropic.model', 'claude-sonnet-4-20250514'));
            $anthropicService->setMaxTokens(1500); // DAHA KISA ƒ∞√áERƒ∞K ƒ∞√áƒ∞N

            Log::info('üîç Claude Vision API √ßaƒürƒ±sƒ± yapƒ±lƒ±yor', [
                'analysis_type' => $analysisType,
                'mime_type' => $mimeType,
                'api_key_prefix' => substr($apiKey, 0, 10) . '...'
            ]);

            $messages = [
                [
                    'role' => 'user',
                    'content' => [
                        [
                            'type' => 'text',
                            'text' => $analysisPrompt
                        ],
                        [
                            'type' => 'image',
                            'source' => [
                                'type' => 'base64',
                                'media_type' => $mimeType,
                                'data' => $imageData
                            ]
                        ]
                    ]
                ]
            ];

            $response = $anthropicService->generateCompletionStream($messages);
            $content = $response['response'] ?? $response;

            return [
                'content' => $content,
                'layout' => $this->extractLayoutInfoFromResponse($content)
            ];

        } catch (\Exception $e) {
            Log::error('‚ùå Image AI analysis error: ' . $e->getMessage());

            // Fallback: Basic image description
            return [
                'content' => 'Image analysis failed: ' . $e->getMessage() . '. Please provide manual description.',
                'layout' => []
            ];
        }
    }

    // üóëÔ∏è AI ENHANCEMENT Sƒ∞Lƒ∞NDƒ∞ - Gereksizdi!

    /**
     * Image analysis prompt builder
     */
    private function buildImageAnalysisPrompt(string $analysisType): string
    {
        $defaultLanguage = $this->getTenantDefaultLanguage();
        $languageName = $this->getLanguageName($defaultLanguage);

        if ($analysisType === 'layout_preserve') {
            return "SADECE {$languageName} Dƒ∞Lƒ∞NDE! Bu g√∂rseli analiz et:

1. LAYOUT ANALƒ∞Zƒ∞:
   - Sayfa d√ºzeni (header, sidebar, main content, footer)
   - Grid sistem (ka√ß s√ºtun, nasƒ±l b√∂l√ºnm√º≈ü)
   - Spacing ve margin'lar
   - Element hierarchisi

2. TASARIM √ñGELERƒ∞:
   - Renk paleti (dominant renkler)
   - Typography (ba≈ülƒ±k, metin boyutlarƒ±)
   - Button stilleri
   - Card/container tasarƒ±mlarƒ±

3. ƒ∞√áERƒ∞K √áIKARIMI:
   - T√ºm metin i√ßeriƒüi
   - Navigation men√º √∂ƒüeleri
   - Ba≈ülƒ±klar ve alt ba≈ülƒ±klar
   - √áaƒürƒ± metinleri (CTA)

4. WEB ELEMENT TESPƒ∞Tƒ∞:
   - Form alanlarƒ±
   - Butonlar ve linkler
   - ƒ∞konlar ve g√∂rseller
   - Liste yapƒ±larƒ±

Bu bilgileri kullanarak Tailwind CSS + Alpine.js ile aynƒ± g√∂r√ºn√ºmde modern web tasarƒ±mƒ± olu≈üturacaƒüƒ±m. L√ºtfen detaylƒ± ve yapƒ±landƒ±rƒ±lmƒ±≈ü bilgi ver.";
        } else {
            return "SADECE {$languageName} Dƒ∞Lƒ∞NDE! Bu g√∂rselden i√ßerik √ßƒ±kar:

1. T√ºm metin i√ßeriƒüi (ba≈ülƒ±klar, paragraflar, listeler)
2. Navigation √∂ƒüeleri
3. Buton/link metinleri
4. Form label'larƒ±
5. √áaƒürƒ± metinleri (CTA)

Tasarƒ±m bilgilerine gerek yok, sadece i√ßerik odaklƒ± √ßƒ±karƒ±m yap. Modern web sitesi olu≈ütururken bu i√ßeriƒüi kullanacaƒüƒ±m.";
        }
    }

    /**
     * Enhancement prompt builder
     */
    private function buildEnhancementPrompt(string $content, string $analysisType, string $fileType, array $layoutInfo): string
    {
        // Tenant'ƒ±n varsayƒ±lan dilini al
        $defaultLanguage = $this->getTenantDefaultLanguage();
        // TemplateEngine entegrasyonu - PDF analizi i√ßin template based approach
        $templateContext = [
            'file_type' => $fileType,
            'analysis_type' => $analysisType,
            'content_preview' => substr($content, 0, 500),
            'layout_info' => $layoutInfo,
            'current_date' => date('d.m.Y'),
            'current_time' => date('H:i')
        ];

        // PDF Content Generation i√ßin √∂zel AI Feature olu≈ütur (mock)
        $pdfFeature = new \Modules\AI\App\Models\AIFeature([
            'name' => 'PDF Premium Landing Generator',
            'slug' => 'pdf-premium-landing-generator',
            'type' => 'content_creator',
            'quick_prompt' => 'PDF dosyalarƒ±ndan ultra premium landing page olu≈ütur',
            'response_template' => json_encode([
                'format' => 'ultra_premium_landing',
                'style' => 'modern_premium',
                'sections' => ['hero', 'features', 'stats', 'cta'],
                'show_original' => false
            ])
        ]);

        // üöÄ S√úPER Mƒ∞Nƒ∞MAL - sadece talebi g√∂nder!
        $userPrompt = "PDF ‚Üí landing page olu≈ütur";
        $templateBasedPrompt = \Modules\AI\App\Services\ResponseTemplateEngine::generateMinimalPrompt($userPrompt, $content);

        Log::info('üé® Minimal prompt generated', [
            'template_length' => strlen($templateBasedPrompt)
        ]);

        // ‚úÖ Sadece dil + minimal prompt
        $finalPrompt = "Dil: " . strtoupper($this->getLanguageName($defaultLanguage)) . "\n\n" . $templateBasedPrompt;

        return $finalPrompt;
    }

    /**
     * File type detection
     */
    private function detectFileType(UploadedFile $file): string
    {
        $mimeType = $file->getMimeType();

        if ($mimeType === 'application/pdf') {
            return 'pdf';
        }

        if (str_starts_with($mimeType, 'image/')) {
            return 'image';
        }

        throw new \Exception('Unsupported file type: ' . $mimeType);
    }

    /**
     * üóëÔ∏è INSTANT CLEANUP - Ge√ßici dosyalarƒ± hemen temizle
     */
    private function cleanupTempFiles(array $tempPaths): void
    {
        foreach ($tempPaths as $tempPath) {
            try {
                if ($tempPath && Storage::disk('local')->exists($tempPath)) {
                    Storage::disk('local')->delete($tempPath);
                    Log::info('‚úÖ INSTANT cleanup: ' . $tempPath);
                }
            } catch (\Exception $e) {
                Log::warning('‚ö†Ô∏è Instant cleanup failed: ' . $tempPath . ' - ' . $e->getMessage());
                // Hata durumunda delayed cleanup job'a bƒ±rak
            }
        }
    }


    // Helper methods for PDF text analysis
    private function detectTextBlocks($page): array
    {
        // Basic implementation
        return ['text_blocks' => 'detected'];
    }

    private function detectHeadings($page): array
    {
        // Basic implementation
        return ['headings' => 'detected'];
    }

    private function detectLists($page): array
    {
        // Basic implementation
        return ['lists' => 'detected'];
    }

    private function extractLayoutInfoFromResponse($response): array
    {
        // Parse AI response for layout info
        return ['layout_extracted' => true];
    }

    private function combineMultipleFileContents(array $results, string $analysisType): string
    {
        $combined = '';
        foreach ($results as $result) {
            if ($result['success']) {
                $combined .= "\n\n=== " . $result['file_name'] . " ===\n" . $result['extracted_content'];
            }
        }
        return trim($combined);
    }

    private function generateAnalysisSummary(array $results): array
    {
        return [
            'total_files' => count($results),
            'successful_analyses' => count(array_filter($results, fn($r) => $r['success'] ?? false)),
            'file_types' => array_unique(array_column($results, 'file_type'))
        ];
    }

    /**
     * Tenant'ƒ±n varsayƒ±lan dilini al
     */
    private function getTenantDefaultLanguage(): string
    {
        try {
            // Site'ƒ±n varsayƒ±lan dilini al (site_languages'dan)
            $siteLocale = config('app.site_locale');
            if ($siteLocale) {
                return $siteLocale;
            }

            // Tenant locale varsa onu kullan
            $tenantLocale = config('app.tenant_locale');
            if ($tenantLocale) {
                return $tenantLocale;
            }

            // Site languages'dan ilk dili al
            $siteLanguages = config('app.site_languages', []);
            if (!empty($siteLanguages) && is_array($siteLanguages)) {
                return reset($siteLanguages); // ƒ∞lk dili al
            }

            // Fallback
            return config('app.locale', 'tr');

        } catch (\Exception $e) {
            Log::warning('Dil tespiti ba≈üarƒ±sƒ±z, varsayƒ±lan kullanƒ±lƒ±yor', ['error' => $e->getMessage()]);
            return 'tr';
        }
    }

    /**
     * Dil kodundan dil adƒ±nƒ± al
     */
    private function getLanguageName(string $langCode): string
    {
        $languages = [
            'tr' => 'T√úRK√áE',
            'en' => 'ƒ∞NGƒ∞Lƒ∞ZCE',
            'de' => 'ALMANCA',
            'fr' => 'FRANSIZCA',
            'es' => 'ƒ∞SPANYOLCA',
            'ar' => 'ARAP√áA',
            'ru' => 'RUS√áA',
            'zh' => '√áƒ∞NCE',
            'ja' => 'JAPONCA',
            'ko' => 'KORECE',
            'it' => 'ƒ∞TALYANCA',
            'pt' => 'PORTEKIZCE'
        ];

        return $languages[$langCode] ?? strtoupper($langCode);
    }

    /**
     * üñºÔ∏è PDF ƒ∞√áƒ∞NDEKƒ∞ G√ñRSELLER - PDF'den g√∂rsel √ßƒ±kar ve listele
     */
    private function extractPDFImages(string $pdfPath): array
    {
        try {
            if (!class_exists('\\Smalot\\PdfParser\\Parser')) {
                Log::warning('‚ö†Ô∏è smalot/pdfparser not installed, cannot extract PDF images');
                return [
                    [
                        'type' => 'note',
                        'message' => 'PDF g√∂rsel √ßƒ±karma i√ßin smalot/pdfparser paketi gerekli',
                        'instructions' => 'composer require smalot/pdfparser'
                    ]
                ];
            }

            $parser = new \Smalot\PdfParser\Parser();
            $pdf = $parser->parseFile($pdfPath);
            $pages = $pdf->getPages();

            $extractedImages = [];
            $imageCounter = 1;

            foreach ($pages as $pageNum => $page) {
                try {
                    // Page objects'i al
                    $objects = $page->getXObjects();

                    foreach ($objects as $objectName => $object) {
                        // Image object'i kontrol et
                        if ($this->isImageObject($object)) {
                            $imageInfo = $this->processImageObject($object, $pageNum + 1, $imageCounter);
                            if ($imageInfo) {
                                // üîç OCR - G√∂rsel i√ßindeki text'i √ßƒ±kar
                                $imageInfo = $this->addOCRTextToImage($imageInfo, $object);
                                $extractedImages[] = $imageInfo;
                                $imageCounter++;
                            }
                        }
                    }
                } catch (\Exception $e) {
                    Log::warning("‚ö†Ô∏è Sayfa {$pageNum} g√∂rsel √ßƒ±karma hatasƒ±: " . $e->getMessage());
                    continue;
                }
            }

            // Eƒüer hi√ß g√∂rsel bulunamazsa bilgi mesajƒ± ekle
            if (empty($extractedImages)) {
                $extractedImages[] = [
                    'type' => 'info',
                    'message' => 'Bu PDF\'de g√∂rsel bulunamadƒ± veya g√∂rseller √ßƒ±karƒ±lamadƒ±',
                    'page' => 'all',
                    'suggestion' => 'PDF\'de g√∂m√ºl√º g√∂rseller varsa, farklƒ± bir PDF formatƒ± deneyin'
                ];
            }

            Log::info('üñºÔ∏è PDF g√∂rsel extraction tamamlandƒ±', [
                'total_pages' => count($pages),
                'extracted_images' => count($extractedImages),
                'image_types' => array_unique(array_column($extractedImages, 'type'))
            ]);

            return $extractedImages;

        } catch (\Exception $e) {
            Log::error('‚ùå PDF g√∂rsel extraction hatasƒ±: ' . $e->getMessage());
            return [
                [
                    'type' => 'error',
                    'message' => 'PDF g√∂rsel √ßƒ±karma ba≈üarƒ±sƒ±z: ' . $e->getMessage(),
                    'page' => 'unknown'
                ]
            ];
        }
    }

    /**
     * Object'in image olup olmadƒ±ƒüƒ±nƒ± kontrol et
     */
    private function isImageObject($object): bool
    {
        try {
            // Object details'i kontrol et
            $details = $object->getDetails();

            // Subtype kontrol√º
            if (isset($details['Subtype']) && in_array($details['Subtype'], ['Image', '/Image'])) {
                return true;
            }

            // Filter kontrol√º (image compression types)
            if (isset($details['Filter'])) {
                $filters = is_array($details['Filter']) ? $details['Filter'] : [$details['Filter']];
                $imageFilters = ['DCTDecode', 'CCITTFaxDecode', 'JBIG2Decode', 'JPXDecode'];

                foreach ($filters as $filter) {
                    if (in_array($filter, $imageFilters)) {
                        return true;
                    }
                }
            }

            return false;

        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Image object'ini i≈üle ve bilgilerini √ßƒ±kar
     */
    private function processImageObject($object, int $pageNum, int $imageCounter): ?array
    {
        try {
            $details = $object->getDetails();

            // G√∂rsel bilgilerini √ßƒ±kar
            $width = $details['Width'] ?? 'unknown';
            $height = $details['Height'] ?? 'unknown';
            $colorSpace = $details['ColorSpace'] ?? 'unknown';
            $bitsPerComponent = $details['BitsPerComponent'] ?? 'unknown';
            $filter = $details['Filter'] ?? 'unknown';

            // Image format'ƒ± tahmin et
            $imageFormat = $this->guessImageFormat($filter, $details);

            // Size tahmin et
            $estimatedSize = $this->estimateImageSize($width, $height, $bitsPerComponent, $colorSpace);

            return [
                'type' => 'image',
                'id' => "img_{$pageNum}_{$imageCounter}",
                'page' => $pageNum,
                'position' => $imageCounter,
                'dimensions' => [
                    'width' => $width,
                    'height' => $height
                ],
                'format' => $imageFormat,
                'color_space' => $colorSpace,
                'bits_per_component' => $bitsPerComponent,
                'compression' => $filter,
                'estimated_size' => $estimatedSize,
                'description' => "Sayfa {$pageNum}'de bulunan g√∂rsel #{$imageCounter}",
                'technical_info' => [
                    'filter' => $filter,
                    'color_space' => $colorSpace,
                    'dimensions' => "{$width}x{$height}",
                    'compression_type' => $this->getCompressionType($filter)
                ]
            ];

        } catch (\Exception $e) {
            Log::warning("Image object i≈üleme hatasƒ±: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Filter'dan image format'ƒ± tahmin et
     */
    private function guessImageFormat($filter, array $details): string
    {
        if (is_array($filter)) {
            $filter = reset($filter);
        }

        switch ($filter) {
            case 'DCTDecode':
                return 'JPEG';
            case 'CCITTFaxDecode':
                return 'TIFF/Fax';
            case 'JBIG2Decode':
                return 'JBIG2';
            case 'JPXDecode':
                return 'JPEG2000';
            case 'FlateDecode':
                return 'PNG-like';
            default:
                return 'Unknown';
        }
    }

    /**
     * Image boyutunu tahmin et
     */
    private function estimateImageSize($width, $height, $bitsPerComponent, $colorSpace): string
    {
        try {
            if ($width === 'unknown' || $height === 'unknown') {
                return 'Unknown size';
            }

            $pixels = (int) $width * (int) $height;
            $channels = $this->getColorChannels($colorSpace);
            $bits = (int) ($bitsPerComponent === 'unknown' ? 8 : $bitsPerComponent);

            $estimatedBytes = ($pixels * $channels * $bits) / 8;

            if ($estimatedBytes > 1024 * 1024) {
                return round($estimatedBytes / (1024 * 1024), 2) . ' MB';
            } elseif ($estimatedBytes > 1024) {
                return round($estimatedBytes / 1024, 2) . ' KB';
            } else {
                return round($estimatedBytes) . ' bytes';
            }

        } catch (\Exception $e) {
            return 'Size calculation failed';
        }
    }

    /**
     * Color space'den kanal sayƒ±sƒ±nƒ± tahmin et
     */
    private function getColorChannels($colorSpace): int
    {
        if (is_array($colorSpace)) {
            $colorSpace = reset($colorSpace);
        }

        switch ($colorSpace) {
            case 'DeviceGray':
            case '/DeviceGray':
                return 1; // Grayscale
            case 'DeviceRGB':
            case '/DeviceRGB':
                return 3; // RGB
            case 'DeviceCMYK':
            case '/DeviceCMYK':
                return 4; // CMYK
            default:
                return 3; // Default RGB
        }
    }

    /**
     * Compression type a√ßƒ±klamasƒ±
     */
    private function getCompressionType($filter): string
    {
        if (is_array($filter)) {
            $filter = reset($filter);
        }

        switch ($filter) {
            case 'DCTDecode':
                return 'JPEG compression (lossy)';
            case 'CCITTFaxDecode':
                return 'CCITT Fax compression (lossless)';
            case 'JBIG2Decode':
                return 'JBIG2 compression (lossless)';
            case 'JPXDecode':
                return 'JPEG 2000 compression';
            case 'FlateDecode':
                return 'Flate compression (lossless)';
            default:
                return 'Unknown compression';
        }
    }

    /**
     * üîç OCR - PDF g√∂rselinin i√ßindeki text'i √ßƒ±kar
     */
    private function addOCRTextToImage(array $imageInfo, $imageObject): array
    {
        try {
            // OCR etkinle≈ütirme kontrol√º
            if (!class_exists('\\thiagoalessio\\TesseractOCR\\TesseractOCR')) {
                Log::warning('‚ö†Ô∏è tesseract_ocr not installed, skipping OCR');
                $imageInfo['ocr_text'] = null;
                $imageInfo['ocr_status'] = 'tesseract_not_available';
                $imageInfo['ocr_note'] = 'OCR i√ßin tesseract_ocr paketi gerekli: composer require thiagoalessio/tesseract_ocr';
                return $imageInfo;
            }

            // Image data √ßƒ±karma (PDF'den binary veri al)
            $imageData = $this->extractImageDataFromPDFObject($imageObject);

            if (!$imageData) {
                $imageInfo['ocr_text'] = null;
                $imageInfo['ocr_status'] = 'image_data_extraction_failed';
                $imageInfo['ocr_note'] = 'G√∂rsel verisi PDF\'den √ßƒ±karƒ±lamadƒ±';
                return $imageInfo;
            }

            // Ge√ßici dosya olu≈ütur
            $tempImagePath = $this->createTempImageFile($imageData, $imageInfo['format']);

            if (!$tempImagePath) {
                $imageInfo['ocr_text'] = null;
                $imageInfo['ocr_status'] = 'temp_file_creation_failed';
                return $imageInfo;
            }

            // OCR i≈ülemi
            $ocrText = $this->performOCR($tempImagePath);

            // Temp dosyayƒ± temizle
            if (file_exists($tempImagePath)) {
                unlink($tempImagePath);
            }

            // OCR sonu√ßlarƒ±nƒ± ekle
            $imageInfo['ocr_text'] = $ocrText['text'];
            $imageInfo['ocr_status'] = $ocrText['status'];
            $imageInfo['ocr_confidence'] = $ocrText['confidence'] ?? null;
            $imageInfo['ocr_language'] = $ocrText['language'] ?? 'auto';
            $imageInfo['ocr_word_count'] = $ocrText['word_count'] ?? 0;

            // Text varsa description'ƒ± g√ºncelle
            if (!empty($ocrText['text']) && strlen(trim($ocrText['text'])) > 0) {
                $imageInfo['description'] .= " - ƒ∞√ßerik: " . substr(trim($ocrText['text']), 0, 100) . "...";
                $imageInfo['has_text_content'] = true;
            } else {
                $imageInfo['has_text_content'] = false;
            }

            Log::info('üîç OCR i≈ülemi tamamlandƒ±', [
                'image_id' => $imageInfo['id'],
                'ocr_status' => $ocrText['status'],
                'text_length' => strlen($ocrText['text'] ?? ''),
                'has_content' => !empty($ocrText['text'])
            ]);

            return $imageInfo;

        } catch (\Exception $e) {
            Log::error('‚ùå OCR i≈ülemi hatasƒ±: ' . $e->getMessage());
            $imageInfo['ocr_text'] = null;
            $imageInfo['ocr_status'] = 'ocr_error';
            $imageInfo['ocr_error'] = $e->getMessage();
            return $imageInfo;
        }
    }

    /**
     * PDF object'inden image data √ßƒ±kar
     */
    private function extractImageDataFromPDFObject($imageObject): ?string
    {
        try {
            // PDF object'den raw data al
            $content = $imageObject->getContent();

            if (empty($content)) {
                return null;
            }

            // Basic filtering - PDF stream data olabilir
            return $content;

        } catch (\Exception $e) {
            Log::warning('PDF image data extraction failed: ' . $e->getMessage());
            return null;
        }
    }

    /**
     * Ge√ßici image dosyasƒ± olu≈ütur
     */
    private function createTempImageFile(string $imageData, string $format): ?string
    {
        try {
            // Format'a g√∂re extension belirle
            $extension = $this->getImageExtension($format);
            $tempPath = tempnam(sys_get_temp_dir(), 'pdf_ocr_') . '.' . $extension;

            // Raw data'yƒ± dosyaya yaz
            if (file_put_contents($tempPath, $imageData) === false) {
                return null;
            }

            // Dosya var mƒ± kontrol et
            if (!file_exists($tempPath) || filesize($tempPath) === 0) {
                return null;
            }

            return $tempPath;

        } catch (\Exception $e) {
            Log::warning('Temp image file creation failed: ' . $e->getMessage());
            return null;
        }
    }

    /**
     * Format'dan file extension √ßƒ±kar
     */
    private function getImageExtension(string $format): string
    {
        switch (strtolower($format)) {
            case 'jpeg':
                return 'jpg';
            case 'png-like':
                return 'png';
            case 'tiff/fax':
                return 'tiff';
            default:
                return 'jpg'; // Default JPEG
        }
    }

    /**
     * OCR i≈ülemini ger√ßekle≈ütir
     */
    private function performOCR(string $imagePath): array
    {
        try {
            // Tesseract OCR kullan
            $ocr = new \thiagoalessio\TesseractOCR\TesseractOCR($imagePath);

            // T√ºrk√ße + ƒ∞ngilizce dil desteƒüi
            $ocr->lang('tur+eng');

            // OCR konfig√ºrasyonu
            $ocr->configFile('pdf')  // PDF optimizasyonu
               ->psm(6)              // Uniform text block
               ->oem(3);             // Default OCR Engine Mode

            // OCR √ßalƒ±≈ütƒ±r
            $extractedText = $ocr->run();

            // Text temizleme
            $cleanedText = $this->cleanOCRText($extractedText);

            // Word count
            $wordCount = str_word_count($cleanedText);

            // Confidence hesaplama (basit algoritma)
            $confidence = $this->calculateOCRConfidence($cleanedText);

            return [
                'text' => $cleanedText,
                'status' => 'success',
                'confidence' => $confidence,
                'language' => 'tur+eng',
                'word_count' => $wordCount,
                'raw_text' => $extractedText
            ];

        } catch (\Exception $e) {
            Log::error('OCR processing failed: ' . $e->getMessage());

            return [
                'text' => '',
                'status' => 'failed',
                'error' => $e->getMessage(),
                'confidence' => 0,
                'word_count' => 0
            ];
        }
    }

    /**
     * OCR text'ini temizle
     */
    private function cleanOCRText(string $text): string
    {
        // Basic cleaning
        $cleaned = preg_replace('/\s+/', ' ', $text); // Multiple spaces
        $cleaned = preg_replace('/\n+/', "\n", $cleaned); // Multiple newlines
        $cleaned = trim($cleaned);

        // √áok kƒ±sa text'leri filtrele
        if (strlen($cleaned) < 3) {
            return '';
        }

        return $cleaned;
    }

    /**
     * OCR confidence hesapla (basit algoritma)
     */
    private function calculateOCRConfidence(string $text): float
    {
        if (empty($text)) {
            return 0.0;
        }

        // Fakt√∂rler:
        $confidence = 0.5; // Base confidence

        // Text uzunluƒüu
        if (strlen($text) > 20) {
            $confidence += 0.2;
        }

        // Kelime sayƒ±sƒ±
        $wordCount = str_word_count($text);
        if ($wordCount > 5) {
            $confidence += 0.2;
        }

        // T√ºrk√ße karakterler
        if (preg_match('/[√ßƒüƒ±√∂≈ü√º√áƒûI√ñ≈û√ú]/', $text)) {
            $confidence += 0.1;
        }

        return min(1.0, $confidence);
    }
}